/*******************************************************************************
 * The Things Network - ABP Feather
 *
 * Example of using an Adafruit Feather M0 and DHT22 with a
 * single-channel TheThingsNetwork gateway.
 *
 * This uses ABP (Activation by Personalization), where session keys for
 * communication would be assigned/generated by TTN and hard-coded on the device.
 *
 * Learn Guide: https://learn.adafruit.com/lora-pi
 *
 * Copyright (c) 2015 Thomas Telkamp and Matthijs Kooijman
 * Copyright (c) 2018 Terry Moore, MCCI
 * Copyright (c) 2018 Brent Rubell, Adafruit Industries
 *
 * Permission is hereby granted, free of charge, to anyone
 * obtaining a copy of this document and accompanying files,
 * to do whatever they want with them without any restriction,
 * including, but not limited to, copying, modification and redistribution.
 * NO WARRANTY OF ANY KIND IS PROVIDED.
 *******************************************************************************/
#include <lmic.h>
#include <hal/hal.h>
#include <SPI.h>

#define LMIC_PRINTF_TO SeerialUSB // not sure!

// Heartbeat timer
unsigned long millsCounter = 0;

// For normal use, we require that you edit the sketch to replace FILLMEIN
// with values assigned by the TTN console. However, for regression tests,
// we want to be able to compile these scripts. The regression tests define
// COMPILE_REGRESSION_TEST, and in that case we define FILLMEIN to a non-
// working but innocuous value.
//
#ifdef COMPILE_REGRESSION_TEST
# define FILLMEIN 0
#else
# warning "You must replace the values marked FILLMEIN with real values from the TTN control panel!"
# define FILLMEIN (#dont edit this, edit the lines that use FILLMEIN)
#endif

// LoRaWAN NwkSKey, network session key (These keys will be deleted after test, so dont get excited!)
static const PROGMEM u1_t NWKSKEY[16] = { 0x06, 0x5F, 0x5D, 0xA2, 0x71, 0xED, 0xE7, 0x1C, 0xC9, 0x9E, 0x05, 0xCD, 0x09, 0x0D, 0xAA, 0xC2 };

// LoRaWAN AppSKey, application session key
static const u1_t PROGMEM APPSKEY[16] = { 0x92, 0xB2, 0x79, 0x75, 0xCF, 0xB8, 0x07, 0x80, 0xB1, 0x2C, 0x9C, 0xB5, 0xC6, 0x4E, 0x6F, 0xC7 };

// LoRaWAN end-device address (DevAddr)
// See http://thethingsnetwork.org/wiki/AddressSpace
// The library converts the address to network byte order as needed.
#ifndef COMPILE_REGRESSION_TEST
static const u4_t DEVADDR = 0x260DA1C5;
#else
static const u4_t DEVADDR = 0x260DA1C5;
#endif

// These callbacks are only used in over-the-air activation, so they are
// left empty here (we cannot leave them out completely unless
// DISABLE_JOIN is set in arduino-lmic/project_config/lmic_project_config.h,
// otherwise the linker will complain).
void os_getArtEui (u1_t* buf) { }
void os_getDevEui (u1_t* buf) { }
void os_getDevKey (u1_t* buf) { }

// payload to send to TTN gateway
static uint8_t payload[5];
static osjob_t sendjob;

// Schedule TX every this many seconds (might become longer due to duty cycle limitations)
const unsigned TX_INTERVAL = 5; //30

// Pin mapping for SparkFun RAMD21 RF Pro Lora
// Please ensure Lora jumpers set
const lmic_pinmap lmic_pins = { // Pinouts for SAMD21 Pro RF
    .nss = 12,
    .rxtx = LMIC_UNUSED_PIN,
    .rst = 7,
    .dio = {6, 10, 11},
    .rxtx_rx_active = 0,
    .rssi_cal = 8,              // LBT cal for the Adafruit Feather M0 LoRa, in dB
    .spi_freq = 8000000,
};

void setup() {
    delay(2500);
    //while (!Serial); // Wait for Terminal connection before start
    SerialUSB.begin(115200);
    delay(100);
    SerialUSB.println(F("Starting"));

    // Setup LEDS
    digitalWrite(LED_BUILTIN, HIGH); // on [Blue], active high [used as heartbeat status for showing software running on SAMD21 module]
    digitalWrite(PIN_LED_RXL, HIGH); // on [Yellow], active low [handled inside LIMC]
    digitalWrite(PIN_LED_TXL, HIGH); // on [Greene], active low [handled inside LIMC]

    // LMIC init
    os_init();
    // Reset the MAC state. Session and pending data transfers will be discarded.
    LMIC_reset();

    // Set static session parameters. Instead of dynamically establishing a session
    // by joining the network, precomputed session parameters are be provided.
    // On AVR, these values are stored in flash and only copied to RAM
    // once. Copy them to a temporary buffer here, LMIC_setSession will
    // copy them into a buffer of its own again.
    uint8_t appskey[sizeof(APPSKEY)];
    uint8_t nwkskey[sizeof(NWKSKEY)];
    memcpy_P(appskey, APPSKEY, sizeof(APPSKEY));
    memcpy_P(nwkskey, NWKSKEY, sizeof(NWKSKEY));
    LMIC_setSession (0x13, DEVADDR, nwkskey, appskey);

   SerialUSB.print("APPSKEY: ");
   SerialUSB.println(APPSKEY[0]);

    // ** Part of 'work-around' for getting LG02 working with TTN API's that now discourage Single Channel LoraWAN Gateway use on their network!
    // We'll disable all 72 channels used by TTN
    for (int c = 0; c < 72; c++){
      LMIC_disableChannel(c);
    }

 // Force
//    LMIC_setupChannel(16, 905500000, DR_RANGE_MAP(DR_SF7, DR_SF7), 1);      // [s1_t band] BAND_CENTI =1 is enum in limn_eu_like.h 


    // We'll only enable Channel 16 (905.5Mhz) since we're transmitting on a single-channel
    // Setup LG02 Lora setting for both RX/TX radios (dual radio device one for RX one for TX) Freq as 905500000 MHz [US902-928 Ch16?], 125 kHz BW, Spread SF7, Coding Rate 4/5
    LMIC_enableChannel(16);

    // Disable link check validation (automatically enabled
    // during join, but because slow data rates change max TX
    // size, we don't use it in this example.
    LMIC_setLinkCheckMode(0); // Was 0

    // TTN uses SF9 for its RX2 window.
    LMIC.dn2Dr = DR_SF9; // DR_SF7? [doesn't work, why?]? Was DR_DF9 on working example

    // Set data rate and transmit power for uplink
    LMIC_setDrTxpow(DR_SF7,23); //14); // Is this MAX? DR_SF9? [doesn't work] 

    // Start job
    do_send(&sendjob);
}

void loop() {
  
  millsCounter = millis();
  
  if ((millsCounter % 1000) == 0) {
    digitalWrite(LED_BUILTIN, HIGH); // on [Blue]
      SerialUSB.print("Frequency======: "); SerialUSB.print(LMIC.freq); SerialUSB.print(" MHz");
      /* 1000000);
      SerialUSB.print("  .  "); SerialUSB.print(LMIC.freq); // / 100000));// % 10);
      SerialUSB.print("MHz");*/
      SerialUSB.print("  LMIC.datarate: "); SerialUSB.print(LMIC.datarate);
      SerialUSB.print("  LMIC.txpow: "); SerialUSB.print(LMIC.txpow); SerialUSB.print("  LMIC.rssi: "); SerialUSB.println(LMIC.rssi);    
          
  } else if ((millsCounter % 500) == 0)
    digitalWrite(LED_BUILTIN, LOW); // off [Blue]
  
  
  os_runloop_once(); // LMIC OS Loop
}


void onEvent (ev_t ev) {
    SerialUSB.print(os_getTime());
    SerialUSB.print(": ");
    switch(ev) {
        case EV_SCAN_TIMEOUT:
            SerialUSB.println(F("EV_SCAN_TIMEOUT"));
            break;
        case EV_BEACON_FOUND:
            SerialUSB.println(F("EV_BEACON_FOUND"));
            break;
        case EV_BEACON_MISSED:
            SerialUSB.println(F("EV_BEACON_MISSED"));
            break;
        case EV_BEACON_TRACKED:
            SerialUSB.println(F("EV_BEACON_TRACKED"));
            break;
        case EV_JOINING:
            SerialUSB.println(F("EV_JOINING"));
            break;
        case EV_JOINED:
            SerialUSB.println(F("EV_JOINED"));
            break;
        /*
        || This event is defined but not used in the code. No
        || point in wasting codespace on it.
        ||
        || case EV_RFU1:
        ||     SerialUSB.println(F("EV_RFU1"));
        ||     break;
        */
        case EV_JOIN_FAILED:
            SerialUSB.println(F("EV_JOIN_FAILED"));
            break;
        case EV_REJOIN_FAILED:
            SerialUSB.println(F("EV_REJOIN_FAILED"));
            break;
        case EV_TXCOMPLETE:
            SerialUSB.print(F("EV_TXCOMPLETE (includes waiting for RX windows) txrxFlags= "));
            SerialUSB.println(LMIC.txrxFlags);
            if (LMIC.txrxFlags & TXRX_ACK)
              SerialUSB.println(F("Received ack"));
            if (LMIC.dataLen) {
              SerialUSB.print(F("Sent: "));
              SerialUSB.print(LMIC.dataLen);
              SerialUSB.println(F(" bytes of payload"));
            }
            // Schedule next transmission <<<< Sends again after TXCOMPLETE
            os_setTimedCallback(&sendjob, os_getTime()+sec2osticks(TX_INTERVAL), do_send);
            break;
        case EV_LOST_TSYNC:
            SerialUSB.println(F("EV_LOST_TSYNC"));
            break;
        case EV_RESET:
            SerialUSB.println(F("EV_RESET"));
            break;
        case EV_RXCOMPLETE:
            // data received in ping slot
            SerialUSB.println(F("EV_RXCOMPLETE !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"));
            if (LMIC.dataLen) {
              SerialUSB.print(F("Received: "));
              SerialUSB.print(LMIC.dataLen);
              SerialUSB.println(F(" bytes of payload"));
            }        
            break;
        case EV_LINK_DEAD:
            SerialUSB.println(F("EV_LINK_DEAD"));
            break;
        case EV_LINK_ALIVE:
            SerialUSB.println(F("EV_LINK_ALIVE"));
            break;
        /*
        || This event is defined but not used in the code. No
        || point in wasting codespace on it.
        ||
        || case EV_SCAN_FOUND:
        ||    SerialUSB.println(F("EV_SCAN_FOUND"));
        ||    break;
        */
        case EV_TXSTART:
            SerialUSB.println(F("EV_TXSTART"));
            break;
        case EV_TXCANCELED:
            SerialUSB.println(F("EV_TXCANCELED"));
            break;
        case EV_RXSTART:
            /* do not print anything -- it wrecks timing */
            //SerialUSB.println(F("EV_RXSTART"));         
            break;
        case EV_JOIN_TXCOMPLETE:
            SerialUSB.println(F("EV_JOIN_TXCOMPLETE: no JoinAccept"));
            break;
        default:
            SerialUSB.print(F("Unknown event: "));
            SerialUSB.println((unsigned) ev);
            break;
    }
}

void do_send(osjob_t* j){

    // Check if there is not a current TX/RX job running
    if (LMIC.opmode & OP_TXRXPEND) {
        SerialUSB.println(F("OP_TXRXPEND, not sending"));
    } else {
        // Dummy payload just for testing
        payload[0] = 0x00;
        payload[1] = 0xFF;
        payload[2] = 0x11;
        payload[3] = 0x22;

        // prepare upstream data transmission at the next possible time.
        // transmit on port 1 (the first parameter); you can use any value from 1 to 223 (others are reserved).
        // don't request an ack (the last parameter, if not zero, requests an ack from the network).
        // Remember, acks consume a lot of network resources; don't ask for an ack unless you really need it.
        LMIC_setTxData2(1, payload, sizeof(payload)-1, 0); // ...,1); = ACK Confirmation (only 10 per day!? https://www.thethingsnetwork.org/forum/t/read-meta-information-from-ack-packet-arduino-lmic/35935/4)

        SerialUSB.println(F("LMIC_setTxData2() Sending, Packet Queued"));
        //SerialUSB.println(&j);
    }
    // Next TX is scheduled after TX_COMPLETE event.
}
